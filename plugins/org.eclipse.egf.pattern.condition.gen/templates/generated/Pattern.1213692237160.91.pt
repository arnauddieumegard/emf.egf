<%@ jet package="org.eclipse.egf.pattern.condition.gen.condition" class="ConditionGenerator" imports="org.eclipse.egf.common.constant.ICommonConstants org.eclipse.egf.pattern.ecore.PatternHandler org.eclipse.egf.pattern.ecore.PatternHandler.PatternData java.util.* org.eclipse.egf.pattern.relations.ParameterRelation org.eclipse.egf.pattern.production.GeneratedContentProducer org.eclipse.emf.ecore.* org.eclipse.egf.common.helper.EcoreHelper org.eclipse.egf.pattern.ecore.condition.AbstractPatternCondition org.eclipse.egf.pattern.ecore.condition.IConditionConstants org.eclipse.egf.pattern.condition.gen.*" %>

<%
{
// Start of Condition (full id = patternLibrary.1213692227054.90/Pattern.1213692237160.91).
StringBuilder pattern121369223716091BuilderSave = new StringBuilder(stringBuffer);
stringBuffer = new StringBuffer();
%>
<%
// First of all, get pattern data from model path.
String modelPath = (String) context.getContextElementValue("patternModelPath", "asset.1213692164306.87"); //$NON-NLS-1$ //$NON-NLS-2$
// Test model path availability.
if (null == modelPath) {
  return ICommonConstants.EMPTY_STRING;
}
// Load pattern.
PatternData patternData = null;
try {
  patternData = new PatternHandler().load(modelPath);
} catch (Exception e_p) {
  return ICommonConstants.EMPTY_STRING;
}
// Store pattern full id.
context.addContextElement(ConditionExecutionReporter.PATTERN_FULL_ID, patternData.getPattern().getId(), ConditionExecutionReporter.PATTERN_FULL_ID, true);
// Get parameters.
List<ParameterRelation> parameters = patternData.getAllParameters();
if ((null == parameters) || parameters.isEmpty()) {
  // Suspicious call to ConditionGenerator.
  return ICommonConstants.EMPTY_STRING;
}
%>
<%
// And add package declaration.
%>
package <%=org.eclipse.egf.pattern.ecore.PatternConstants.PATTERN_CONDITION_GENERATED_BASE_PACKAGE%>;

<%
// Add imports for all parameters.
for (ParameterRelation parameterRelation : parameters) { // For (parameter import).
  EClass parameterType = parameterRelation.getType();
  String packageImportedName = EcoreHelper.getImportedPackageName(parameterType.getEPackage());
  if (null != packageImportedName) { // If (parameter imported name).
  // Append import directive.
%>
import <%=packageImportedName%>.<%=parameterType.getName()%>;
<%
  } // If (parameter imported name).
%>
<%
} // For (parameter import).
%>
<%
// Add abstract pattern condition class import.
%>
import <%=AbstractPatternCondition.class.getName()%>;

/**
 * Condition class implementation.<br>
 * A merge occurs each time the corresponding pattern parameters are changed.<br>
 * Both check methods are subject to merge (see associated comments).<br>
 * Any other method is left untouched as a result of the merging operation.
 */
public class <%=GeneratedContentProducer.getConditionClassName(patternData)%> extends AbstractPatternCondition {
<%
// Compute methods call and signature.
String methodCall = ICommonConstants.EMPTY_STRING;
String checkImplSignature = ICommonConstants.EMPTY_STRING;
int i = 0;
for (Iterator<ParameterRelation> parametersIterator = parameters.iterator(); parametersIterator.hasNext(); i++) {
  ParameterRelation parameter = parametersIterator.next();
  String parameterType = parameter.getType().getName();
  methodCall += ICommonConstants.PARENTHESIS_OPEN_CHARACTER + parameterType + ICommonConstants.PARENTHESIS_CLOSE_CHARACTER;
  methodCall += "parameters_p[" + i + "]"; //$NON-NLS-1$ //$NON-NLS-2$
  checkImplSignature += parameterType + ICommonConstants.WHITE_SPACE_CHARACTER + parameter.getName();
  if (parametersIterator.hasNext()) {
    methodCall += ICommonConstants.COMMA_CHARACTER;
    checkImplSignature += ICommonConstants.COMMA_CHARACTER;
  }
}
%>
<%
// Add generic check method declaration.
%>
  /**
   * Generated check method.<br>
   * User should left this code untouched for it is lost when a merge is performed.<br>
   * <%=IConditionConstants.UNMODIFIABLE_ANNOTATION_TAG%>
   */
   public boolean check(Object... parameters_p) {
     return check(<%=methodCall%>);
   }

<%
// Add specific (ie typed) check method declaration.
%>
  /**
   * Check method user implementation.<br>
   * User must implement and comment between delimiters only !<br>
   * Public signature and comments are lost when a merge is performed.<br>
   * <%=IConditionConstants.UNMODIFIABLE_ANNOTATION_TAG%>
   */
   public boolean check(<%=checkImplSignature%>) {
     <%=IConditionConstants.USER_CODE_BEGINNING_DELIMITER%>
     return true;
     <%=IConditionConstants.USER_CODE_END_DELIMITER%>
   }
}<%
StringBuilder pattern121369223716091Builder = new StringBuilder(stringBuffer);
stringBuffer = new StringBuffer(pattern121369223716091BuilderSave).append(pattern121369223716091Builder);
reporter.patternExecutionFinished(pattern121369223716091Builder.toString(),"patternLibrary.1213692227054.90/Pattern.1213692237160.91",context);
// End of Condition (full id = patternLibrary.1213692227054.90/Pattern.1213692237160.91).
}
%>
