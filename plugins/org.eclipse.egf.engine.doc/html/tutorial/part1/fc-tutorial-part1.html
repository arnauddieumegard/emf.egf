<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta name="copyright" content="Copyright (c) Thales Corporate Services S.A.S, 2009. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page." >
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>
		Factory Component Tutorial Part 1 (Introduction to EGF components)
	</title>
	<link rel="stylesheet" href="../style/default_style.css" charset="ISO-8859-1" type="text/css" />
</head>

<body xml:lang="EN-US" lang="EN-US">
<div align="right">
  &nbsp;
  <font face="Times New Roman, Times, serif" size="2">
  Copyright Thales Corporate Services S.A.S 2008, 2009
  </font>  
  <table border="0" cellpadding="2" cellspacing="0" width="100%">
    <tbody>
      <tr>
      	<td colspan="2" align="left" bgcolor="#0080c0" valign="top">
      	  <b><font face="Arial,Helvetica"><font color="#ffffff">
      	  &nbsp;EGF Tutorial
      	  </font></font></b>
      	</td>
      </tr>
  	</tbody>
  </table>
</div>

<h1 align="center">Factory Component Tutorial Part 1 (Introduction to EGF components)</h1>

<blockquote>
  <b>Summary</b>
  <br/>
  <p>
  	Generating content such as source code can save you time in your projects and can reduce the 
  	amount of tedious redundant programming. Generating can be powerful, but the program that writes the code
  	can quickly become very complex and hard to understand.
  	One way to reduce complexity and increase readability is to use EGF.
  </p>
  <p>
  	EGF project contains two very powerful tools for generating outputs: The factory component (FC) task factory
  	and the pattern. A factory component, as a software production unit, allows to drive massive code production.
  	A factory component can either directly generate outputs and/or delegate to other factory components the outputs generation,
  	a workflow is established this way.
  </p>
  In this tutorial you will learn how to :
  <ul>
  	<li>create a new factory component</li>
  	<li>create a task factory</li>
  	<li>create a contract</li>
  	<li>create a context</li>
  	<li>execute the factory component</li>
  	<li>use factory component workflow</li>
  	<li>create a factory component by code</li>
  </ul>
  
  <b><div class="author">By Stephane Fournier, Thales Corporate Services S.A.S, stephane.fournier at thalesgroup dot com</div>
  <div class="author">and Guillaume Brocard, Thales Corporate Services S.A.S, guillaume.brocard at thalesgroup dot com</div>
  </b>
  <div class="copyright">Copyright &copy; 2008 Thales Corporate Services S.A.S</div>
  <div class="date">February 28, 2008</div>
  <p/>
  <b>
  <div class="author">Revised by Stephane Fournier, Thales Corporate Services S.A.S, stephane.fournier at thalesgroup dot com</div>
  </b>
  <div class="copyright">Copyright &copy; 2009 Thales Corporate Services S.A.S</div>
  <div class="date">January 30, 2009</div>
</blockquote>
<hr width="100%" />

<h2>Requirements</h2>
<p>
  Before creating our first factory component, you will need the EGF Engine plug-ins.<br/>
  If you haven't installed it yet, you can get a fully package version <a href="http://www.eclipse.org/emf">here</a>.<br/>
  Install it before continuing with this tutorial.
</p>

<h2>HelloWorld Factory Component</h2>
<p>
  Let's start with the famous example of displaying the message "Hello, <tt code="class"> message</tt>" where message is something entred by the end-user.
  So as to create our first example, the following steps are required :<br/>
  <ol>
    <li><a href="#fc1_step1">Create a new Factory Component (FC) project.</a></li>
    <li><a href="#fc1_step2">Create a task factory class.</a></li>
    <li><a href="#fc1_step3">Create a task class.</a></li>
   	<li><a href="#fc1_step4">Create a contract.</a></li>
    <li><a href="#fc1_step5">Create a factory component invocation enabling the task.</a></li>
    <li><a href="#fc1_step6">Create a context based on created contract.</a></li>
    <li><a href="#fc1_step7">Finally, launch a new workbench and execute it.</a></li>
  </ol>

  <a name="fc1_step1"><h3>Step 1. Create a new Factory Component</h3></a>
  <p>
    First, switch to the EGF perspective.
  	<p align="left">
      <img src="./images/egf_perspective.gif" alt="EGF perspective"/>
    </p>
     EGF perspective contains two main views :
     <ul>
     	<li>Factory Component Explorer that displays all factory components under development</li>
     	<li>Factory Components that displays all installed factory components</li>
     </ul>
     and add a shortcut to create a New Factory Component in the 'New Project' item in the coolbar and in the menu bar.
  </p>  
  <p>
    From the workbench menu, select File > New > Project to bring up the New Project wizard. In the EGF category, select the New Factory Component Wizard.
    <p align="left">
      <img src="./images/egf_new_fc_project_wizard.gif" alt="New Factory Component wizard"/>
    </p>
    <p align="left">
      <img src="./images/TryIt.gif" />
      You can also bring up the New Factory Component Wizard from the contextual menu.
      	<p align="left">
      		<img src="./images/egf_new_fc_project_wizard_popup.gif" />
    	</p>
    </p>
    Click Next, the FC wizard project page is displayed as shown in the image below.
    <p align="left">
      <img src="./images/egf_new_fc_wizard_project_page.gif" alt="Factory Component wizard project page"/>
    </p>
    Enter FC project name and give it the name <tt code="class">org.eclipse.egf.examples.fc.helloworld</tt> for instance. It's up to you to enter whatever you want.<br/>
    Click Next, the FC wizard plug-in page is displayed as shown in the image below.
    <p align="left">
      <img src="./images/egf_new_fc_wizard_plugin_page.gif" alt="Factory Component wizard plug-in page"/>
    </p>
    Uncheck the two plug-in checkboxes.<br/>
    Check <b>Yes</b> the Factory Component Model option.<br/>
    Click Next, the available FC creation templates are displayed as shown in the image below.
    <p align="left">
      <img src="./images/egf_new_fc_wizard_templates_page.gif" alt="Factory Component wizard templates page"/>
    </p>
    At the moment, only the Empty FC template is available.
    <p align="left">
      <img src="./images/tip.gif"/> FC templates can be contributed via Extensions that match the <tt code="class">org.eclipse.egf.pde.factoryComponentContent</tt> Extension-Point.
    </p>
    Select the Empty FC template and click Next.<br/>
    The Empty FC page is displayed as shown below and allows you to enter a user-friendly name for your FC, give it the name <b>Helloworld</b>.
    <p align="left">
      <img src="./images/egf_new_fc_wizard_empty_template_page.gif" alt="Empty FC template page"/> 
    </p>
    Finally click Finish.<br/>
    The FC is created and displayed in the Factory Component Explorer view.<br/> Check the "Activate this plug-in when one of its classes is loaded" option in the open Plug-in Editor.<br/>
    Expand the Helloworld node in the Factory Component Explorer view to have a look at the created structure.
    <p align="left">
      <img src="./images/egf_fc_helloworld_just_created.gif" alt="Helloworld FC created"/> 
    </p>
  </p>

  <a name="fc1_step2"><h3>Step 2. Create a task factory class</h3></a>
  <p>
    To display the famous message, our FC need to be productive. It is achieved by filling it with a task factory.<br/>
    Let's create a task factory. This one must implement <tt code="class">org.eclipse.egf.core.task.ITaskFactory</tt> interface as shown in the image below.
    <p align="left">
      <img src="./images/egf_fc_helloworld_task_factory_class.gif" alt="Create a Task Factory"/> 
    </p>
    Give it the name class <b>HelloworldTaskFactory</b> and click Finish.
    <p align="left">
      <img src="./images/tip.gif"/> Check the "Inherited abstract methods" option to help you to implement the class.
    </p>
    <p align="left">
      <img src="./images/tip.gif"/> You can notice the created class is located in package named x.y.<b>tasks</b> in the <tt code="class">src</tt> source folder 
      as it is not a generated artifact. 
    </p>
    The created HelloworldTaskFactory needs to have its "createTask" method implemented.
    <p align="left">
      <img src="./images/egf_fc_helloworld_task_factory_code.gif" alt="HelloworldTaskFactory created"/>
    </p>
  </p>

  <a name="fc1_step3"><h3>Step 3. Create a task class</h3></a>
  <p>
    The task is in charge of what it's done. Here, we will implement a code that displays the famous message to the end-user.
    First, let's create a task. This one must extend <tt code="class">org.eclipse.egf.core.task.AbstractTask</tt> class as shown in the image below.
    <p align="left">
      <img src="./images/egf_fc_helloworld_task_class.gif" alt="Create a Task"/> 
    </p>
    Give it the name class <b>HelloworldTask</b> and click Finish.
    <p align="left">
      <img src="./images/tip.gif"/> Check the "Inherited abstract methods" option to help you to implement the class.
    </p>
    <p align="left">
      <img src="./images/tip.gif"/> You can notice the created class is located in package named x.y.<b>tasks</b> in the <tt code="class">src</tt> source folder 
      as it is not a generated artifact. 
    </p>
    The created HelloworldTask needs to have its "doExecute" method implemented. We will implement it later.
    <p align="left">
      <img src="./images/egf_fc_helloworld_task_code.gif" alt="HelloworldTask created"/>
    </p>
    Now, we can implement the <tt code="class">HelloworldTaskFactory</tt> in instantiating the <tt code="class">HelloworldTask</tt> as shown below.
    <pre class="code">
  public AbstractTask createTask() {
    return new HelloworldTask();
  }
    </pre> 
  </p>
  
  <a name="fc1_step4"><h3>Step 4. Create a contract</h3></a>
  <p>
  	<p>
  	We want to add an additional message to the Hello message display.<br/>
  	To do that we need a valued variable that is used at the runtime time (N.B : the display is performed by the task implementation).<br/>
  	In EGF such a variable is a <b>Contract Element</b>. A contract element can reference another contract element. Hence, the value provided for the first one
  	will be automatically forwarded to the referenced one and so on...
  	</p>
  	Let's create a contract that is used to hold the additional message.<br/>
  	<li>In the Factory Component Explorer, expand nodes to reach the Contract.</li>
  	<li>Right click the Contract New > Contract Element.</li><br/>
  	The Contract Element wizard is displayed as shown in the image below.
  	<p align="left">
      <img src="./images/egf_fc_helloworld_contract_wizard_1.gif" alt="Contract Element wizard"/>
    </p>
    <li>Enter its key name, give it <b>message</b>.</li>
  	<li>Enter its description, give it <b>User message to display</b>.</li>
  	<p align="left">
      <img src="./images/tip.gif"/> Description will be useful at the context element creation time, this concept is explained <a href="#fc1_step6">later</a>.
    </p>
    <li>The <b>mandatory</b> option is used to flag if this contract element is mandatory or optional regarding the task that uses it.</li>
    <li>Click Next</li>
    <p align="left">
      <img src="./images/egf_fc_helloworld_contract_wizard_type.gif" alt="Contract Element Type wizard"/>
    </p>
    <li>Click the Browse button to select its type, here enter <b>StringTypeHolder</b>. A contract element type is encapsulated in an <tt code="class">org.eclipse.egf.model.contract.type.ITypeHolder</tt> to avoid Eclipse class loader issues at runtime.</li><br/>
    <br/>EGF provides default type holders : StringTypeHolder (String), BooleanTypeHolder (boolean), ClassTypeHolder (Class), ...<br/>
    Have a look at the hierarchy of <tt code="class">ITypeHolder</tt>.
    <br/><li>Click Finish</li><br/>
    <br/>The created contract element is displayed in Contract as shown in the image below.
    <p align="left">
      <img src="./images/egf_fc_helloworld_contract_wizard_finish.gif" alt="Contract Element created"/>
    </p>
    <p align="left">
      <img src="./images/tip.gif"/> The yellow overlay reminds that the contract element is mandatory. The description is displayed in the status line.
    </p>
    <p>
    Now we can implement the <tt code="class">HelloworldTask</tt> that uses this contract element.<br/>
    <li>In the open Java editor of the <tt code="class">HelloworldTask</tt> class, let's implement it.</li>
    <pre class="code">
  /**
   * Message contract tag used in the helloworld FC.
   */
  private <img src="./images/tag_1.gif"/>static final String CONTRACT_MESSAGE_TAG = "message"; //$NON-NLS-1$
    </pre>
    <p align="left">
      <img src="./images/tag_1.gif"/> Define a constant regarding the <b>message</b> contract to get its value at runtime.
    </p>
    <pre class="code">
  protected boolean doExecute(IProgressMonitor monitor_p) {
    final <img src="./images/tag_2.gif"/>String message = (String) getContextElementValue(CONTRACT_MESSAGE_TAG);
    // Display it to the end-user.
    final Display display = PlatformUI.getWorkbench().getDisplay();
    display.asyncExec(new Runnable() {
      /**
       * @see java.lang.Runnable#run()
       */
      public void run() {
        Shell shell = display.getActiveShell();
        MessageDialog.openInformation(shell, "FC execution", "Hello " + message); //$NON-NLS-1$//$NON-NLS-2$
      }
    });
    return true;
  }
    </pre>
     <p align="left">
      <img src="./images/tag_2.gif"/> the <b>getContextElementValue</b> method provides by <tt code="class">AbstractTask</tt> allows to get the value of a contract element by its key.<br/>
      A valued contract element is named a context element.
     </p>
    <p align="left">
      <img src="./images/tip.gif"/> Don't forget to organize (i.e update) Java imports (key binding : Ctrl+Shift+O).
    </p>
    </p> 
  </p>
  
  <a name="fc1_step5"><h3>Step 5. Create a factory component invocation enabling the task</h3></a>
	<p>
	  	<p>
	  		A FC is executed through its factory. This one contains a production plan that orchestrates the job to be performed.
	  		To create a FC that runs a TaskFactory, we have to create a factory component invocation that references the <b>Bootstrap Factory Component</b> in the production plan.<br/>
	  		The created factory component invocation contains the TaskFactory to execute.
	  	</p>
	  	First, let's create a factory component invocation.
	  	<li>In the Factory Component Explorer, expand nodes to reach the Production Plan (owned by the Factory).</li>
  		<li>Right click the Production Plan New > Factory Component Invocation.</li><br/>
  		The factory component invocation wizard is displayed as shown in the image below.
  		<p align="left">
      		<img src="./images/egf_fc_helloworld_fci_wizard.gif" alt="Factory component invocation wizard"/>
    	</p>
    	<li>Enter its name, give it <b>PrintFamousMessage</b>.</li>
    	<li>Click the Browse button to pick the referenced Factory Component, here the <b>Bootstrap FC</b> as shown in the image below.</li>
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_fci_wizard_fc_selection.gif" alt="Factory component invocation that references Bootstrap FC"/>
    	</p>
    	<br/><li>Click Finish</li><br/>
    	<br/>The created factory component invocation is displayed in Production Plan as shown in the image below.
	    <p align="left">
	      <img src="./images/egf_fc_helloworld_fci_created.gif" alt="Factory component invocation created"/>
	    </p>
	    <br/>
	    Finally, let's create the task factory.
	    <li>Select the created factory component invocation.</li>
	    <li>Right click the Factory Component Invocation New > Task Factory.</li><br/>
	    <br/>The Task factory wizard is displayed as shown in the image below.
	    <p align="left">
      		<img src="./images/egf_fc_helloworld_task_factory_wizard.gif" alt="Task Factory wizard"/>
    	</p>
    	<li>Click the Browse button to pick the created <tt class="code">HelloworldTaskFactory</tt></li>
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_task_factory_wizard_selection.gif" alt="Task Factory that references HelloworldTaskFactory"/>
    	</p>
    	<br/><li>Click Finish</li><br/>
    	<br/>The created task factory is displayed in Factory Component Invocation as shown in the image below.
	    <p align="left">
	      <img src="./images/egf_fc_helloworld_task_factory_wizard_finish.gif" alt="Task Factory created"/>
	    </p>
  	</p>
  	
  	<a name="fc1_step6"><h3>Step 6. Create a context based on created contract</h3></a>
  	<p>
	  	<p>
	  		We have seen that a variable in EGF is named a contract element. The way to set it a value is through a context element.<br/>
	  		Context element can be based on a contract element or a simple couple ((key, type), value).
	  		To provide a context element that values a contract element defined in the same FC, it has to be created in the Production Plan context.
	  	</p>
	  	Let's create a context element that provides our additional message <b>MDE guys</b>.
	  	<li>Right click the Production Plan, New > Context.</li><br/>
	    <br/>The Context element wizard is displayed as shown in the image below.
	    <p align="left">
      		<img src="./images/egf_fc_helloworld_context_wizard_type.gif" alt="Context element wizard"/>
    	</p>
    	<li>Default selection is set to reference a contract element.</li>
    	<li>Click Next to match the contract element as shown in the image below</li>
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_context_wizard_reference.gif" alt="Context element wizard reference page"/>
    	</p>
    	<p align="left">
      		<img src="./images/tip.gif"/> Description of the referenced contract element is displayed (mouse over the contract element) by a tooltip after a delay.
    	</p>
    	<li>Transfer the message contract in th right part of the viewer as shown in the image below.</li>
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_context_wizard_reference_selected.gif" alt="Context element referenced message contract element"/>
    	</p>
    	<li>click Next</li>
    	<li>Enter the value <b>MDE guys</b> as shown in the image below</li>
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_context_wizard_value.gif" alt="Context element value"/>
    	</p>
	</p>
	
	<a name="fc1_step7"><h3>Step 7. Execute the factory component</h3></a>
	<p>
		<p>
	  		To execute a FC as a plug-in, it must be in the target platform.<br/>
	  	</p>
	  	To test our Helloworld FC, launch a new workbench as shown in the image below.
	  	<p align="left">
      		<img src="./images/egf_fc_helloworld_execution_test.gif" alt="Launch a new EGF to execute Helloworld"/>
    	</p>
    	<li>In the Factory Components view, Expand the Helloworld FC</li>.
    	<li> Right click the Factory contained in Helloworld FC as shown in the image below</li>.
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_execution.gif" alt="Execute Helloworld"/>
    	</p>
    	
    	<p>
    	Here we are !!
    	<p align="left">
      		<img src="./images/egf_fc_helloworld_execution_done.gif" alt="Helloworld executed"/>
    	</p>
    	</p>
	</p>
</p>	
	<h2>Use factory component workflow</h2>
	<p>
		<p>
			We have successfully developed a Helloworld FC. It can be executed to display the famous message to end-user.<br/>
			Now, let's imagine, we want to create a new FC that references the Helloworld FC to provide it with the required contract element (i.e message).<br/>
			So, the Helloworld FC won't be directly executed, but referenced by a new FC that provides it with a new message at runtime.<br/>
			In this way, we are building a workflow that chains the FCs.<br/>
			<br/>A FC exposes its contract through its contract elements that are used in its factory.<br />
			When referencing another FC, a FC could value exposed contract elements by referenced FCs or re-export them in creating new contract elements based on them (depending on needs).
			In fact, <b>the contract part can be considered as the FC public API</b>.
		</p>
		<p>
			So as to create our second example, the following steps are required :<br/>
			<ol>
			  <li><a href="#fc2_step1">Create a new FC.</a></li>
			  <li><a href="#fc2_step2">Create a factory component invocation.</a></li>
			  <li><a href="#fc2_step3">Create a context based on Helloworld 'message' contract.</a></li>
			  <li><a href="#fc2_step4">Finally, launch a workbench and execute it.</a></li>
			</ol>
  		</p>
		<p>
			<a name="fc2_step1"><h3>Step 1. Create a new FC</h3></a>
			
				Let's create a new FC as we did <a href="#fc1_step1">at step 1</a> in the previous example.<br/>
				<li>Give it the project name <tt code="class">org.eclipse.egf.examples.fc.helloworld.test</tt></li><br/>
				<li>Give it the FC name <b>Helloworld Test</b></li><br/>
				<br/>You should get what it is shown in the image below.
			  	<p align="left">
		      		<img src="./images/egf_fc_helloworld.test.gif" alt="Helloworld Test FC created"/>
		    	</p>
		    	
		    <a name="fc2_step2"><h3>Step 2. a factory component invocation</h3></a>
		    	<li>Create a factory component invocation <b>referencing the Helloworld FC</b> (see <a href="#fc1_step5">step 5</a> in the previous example)</li><br/>
		    	<li>Give it the name <b>displayMessage</b></li><br/>
		    	<br/>You should get what it is shown in the image below.
			  	<p align="left">
		      		<img src="./images/egf_fc_helloworld.test_fci.gif" alt="Helloworld Test Factory Component Invocation created"/>
		    	</p>
		    	
		    <a name="fc2_step3"><h3>Step 3. Create a context based on Helloworld 'message' contract</h3></a>
		    	We must create a context element that references the <b>message</b> contract element exported by the Helloworld FC.<br/>
		    	
		    	<li>Right click  the created Factory Component Invocation in Helloworld Test</li>
		    	<li>Follow wizard instructions to create the context element as we did at step 6. Replace the context element value by a new one (e.g <b>world from test</b>) to see the change.</li><br/>
		    	It should end as shown in the image below.
		    	<p align="left">
		      		<img src="./images/egf_fc_helloworld.test_fci_context_created.gif" alt="Helloworld Test context created"/>
		    	</p>
		    	
		    <a name="fc2_step4"><h3>Step 4. Finally, launch a workbench and execute it</h3></a>
		    	Let's execute the Helloworld Test FC.
		    	<li>Relaunch the workbench used <a href="#fc1_step7">at step 7</a> in the previous example.</li>
		    	<li>Right click Helloworld Test factory as shown in the image below.</li>
		    	<p align="left">
		      		<img src="./images/egf_fc_helloworld.test_execution.gif" alt="Execute Helloworld Test"/>
		    	</p>
		    	<p>
		    	Here we are !!
			    	<p align="left">
			      		<img src="./images/egf_fc_helloworld.test_execution_done.gif" alt="Helloworld executed"/>
			    	</p>
		    	</p>
		    	<p align="left">
      				<img src="./images/tip.gif"/> The context element defined in the Helloworld FC is overridden by the one defined in Helloworld Test FC.
      				FC that defines contract elements can provide default values this way.
    			</p>
		</p>
	</p>

<h2>Dealing with multiples contexts</h2>
	<p>
		Now, we will modify the Helloworld Test FC to deal with multiple contexts in order to understand how it works. 
	    <li>Add a new Factory Component Invocation in the Helloworld Test FC that references Helloworld FC again as we did at <a href="#fc2_step2">step 2</a> in the previous example.</li>
		<li>Create a context based on Helloworld <b>message</b> contract as we did at <a href="#fc2_step3">step 3</a>, give it a new value (e.g <b>world from test 2</b>).</li><br/>
		<br/> At this step, you should get what it is shown in the image below.
			<p align="left">
				<img src="./images/egf_fc_helloworld.test_2_fci.gif" alt="Helloworld Test with 2 factory component invocations"/>
			</p>
		<li>Execute Helloworld Test again as we did at <a href="#fc2_step4">step 4</a>.</li><br/>
		<br/> You should get <b>two different messages displayed</b>.
		<p>
			As you can see the two contexts are isolated. <u>Each factory component invocation has its own context</u>.<br />
		</p>
		<p>	
		Let's imagine we want to display <b>the same message</b> at runtime. So, we don't want to declare contexts twice for a same value at the end.<br />
		The goal is to have only one context value used in both factory component invocations.<br />
		This is achieved here through contract references mechanism and production plan context.<br />
		<ol>
			<li>Delete the existing contexts in Helloworld Test FC.</li>
			<li>Create a contract that references the one provided by Helloworld FC i.e <b>message</b>, give it the name <b>sharedMessage</b>.</li>
			<p align="left">
      			<img src="./images/tip.gif"/> To create a contract that references other ones, check the Reference option in the contract element wizard page. A contract can reference several contract elements but they must have the same type.
    		</p>
			<li>Create a context in Helloworld Test FC production plan that references its own contract <b>sharedMessage</b> and give it a new value (e.g <b>shared message</b>).</li>
		You should get what it is shown in the image below.
		<p align="left">
			<img src="./images/egf_fc_helloworld.test_shared_context.gif" alt="Helloworld Test FC using a shared context"/>
		</p>
		<li>Execute Helloworld Test FC again.</li><br/> 
		<br/> You should get <b>the same message displayed twice</b>.
		</ol>
		Therefore, we learnt how to share contract element values.<br />
		A good exercise would be to delete the production plan context and create a new FC that provides Helloworld Test FC with a context that values <b>sharedMessage</b> contract.
		You should create something closed to what it is shown in the image below to achieve this exercise.
		<p align="left">
			<img src="./images/egf_fc_helloworld.test2.gif" alt="Helloworld Test2"/>
		</p>
		</p>
	</p>

<h2>Create a FC by code</h2>
<p>
  When it comes to giving the context at execution time, then the creation of a dynamic FC is required.<br/>
  Such a FC is a transient one, created in memory, and delegating to the one that we want to feed dynamically.<br/>
  This is achieved here through the use of the task factory.<br/>
  Our example steps are :<br/>
  <ol>
    <li>Create a new FC with a task factory.</li>
    <li>Create a task that uses the FC model API.</li>
    <li>Execute this new FC.</li>
  </ol>

  <h3>Step 1. Create a new FC with a task factory</h3>
  <p>
    Now that you are familiar with the creation of a new FC and a task factory, create it with the <b>HelloWorld Dynamic Test</b> name.<br/>
    <ul>
      <li>Create the FC with the correct name, see <a href="#fc1_step1">HelloWorld step 1</a></li>
      <li>Then create a task factory class, as in <a href="#fc1_step2">HelloWorld step 2</a></li>
      <li>And finally create the factory component invocation enabling our future task, again see <a href="#fc1_step5">HelloWorld step 5</a></li>
    </ul>
    You should be ending in a state very close to the following one :
    <p align="left">
      <img src="./images/egf_new_fc_dynamic_test.gif" alt="The dynamic FC content"/>
    </p>
  </p>

  <h3>Step 2. Create the task</h3>
  <p>
    Create a new task (get a glimpse at <a href="#fc1_step3">HelloWorld step 3</a>).<br/>
    The goal of this task is to read a messages file, to extract the messages, and then to call HelloWorld FC for each message.
    <p>
      <img src="./images/tip.gif"/>Don't forget to register the task in the task factory before proceeding !
    </p>
    <p>
      For now, we will be exposing in detail the content of the <tt class="code">doExecute</tt> method.<br/>
      We'll start with the reading of the file.
      Messages in the messages.txt file are separated by commas in our example.
      <pre class="code">
        // Read the messages file.
        String helloMessages = FileHelper.readFile(PLUGIN_ID + "/resources/messages.txt"); //$NON-NLS-1$
        // Get messages.
        String[] messages = StringHelper.getTokens(helloMessages, ICommonConstants.EMPTY_STRING + ICommonConstants.COMMA_CHARACTER);
      </pre>
      <img src="./images/TryIt.gif"/>The <tt class="code">FileHelper</tt> and <tt class="code">StringHelper</tt> classes are provided
      by EGF Engine. The first one allows to handle files through relative paths (starting with the plug-in id) when the second
      is providing extra services on strings. <tt class="code">FileHelper</tt> accesses workspace or platform resources indifferently.
      <br/>
      <br/>
      All resources are loaded, create the FC model in memory.
      <pre class="code">
        // Create a FC dynamically.
        FactoryComponent dynamicFc = ModelFactory.eINSTANCE.createFactoryComponent();
        dynamicFc.setName("Dynamic HelloWorld Runner"); //$NON-NLS-1$
      </pre>
      You can pick up whatever name is your liking, this is just a logical one that will be displayed when executing its factory.<br/>
      This is the next step, creating the factory.
      <pre class="code">
        // Set the factory.
        Factory factory = ModelFactory.eINSTANCE.createFactory();
        dynamicFc.setFactory(factory);
      </pre>
      A factory is in need for a production plan, let's create it.
      <pre class="code">
        // Add a production plan.
        ProductionPlan productionPlan = ModelFactory.eINSTANCE.createProductionPlan();
        factory.setProductionPlan(productionPlan);
      </pre>
      Add a call to HelloWorld for every message.<br/>
      We'll dig into details, let it just be a method call for now.
      <pre class="code">
        // Add call to HelloWorld for each message.
        for (String message : messages) {
          delegateToHelloWorld(productionPlan, message);
        }
      </pre>
      At this point, the FC is constructed in memory, and ready to be executed.<br/>
      Note that there is no facility to create such a structure for now.<br/>
      So you must carefully respect this process, otherwise the FC would be a corrupted one.<br/>
      The executing code is as follow :
      <pre class="code">
        // Now the FC is ready for action.
        // Register it.
        FactoryComponentRegistry factoryComponentRegistry = CoreActivator.getDefault().getFactoryComponentRegistry();
        String factoryComponentId = factoryComponent.getId();
        factoryComponentRegistry.addFactoryComponent(factoryComponentId, factoryComponent);
        // Execute it.
        boolean result = CoreActivator.getDefault().generateFactoryComponent(factoryComponentId, progressMonitor_p, false);
        // The FC is no longer needed, unregister it.
        factoryComponentRegistry.removeFactoryComponent(factoryComponentId);
      </pre>
      <ol>
      <li>EGF Engine is maintaining a FC registry, that is accessible through the first call.</li>
      <li>
      After registering the new FC, it can be executed.<br/>
      The execution (indeed the generation of an output) is done by the <tt class="code">generateFactoryComponent</tt> method.
      Apart from the FC id, it also asks for two other parameters. The first one is the progress monitor to use during
      the execution. The second one is telling the framework either to fork the generation in a new job (as of Eclipse Job API) if true,
      or to execute it in current thread (false). Should the second option be set to true, then the behavior would lead to calling
      HelloWorld several times in parallel. In this case, the provided progress monitor is ignored since a Job is using its own.
      Here, HelloWorld will be called several times sequentially.
      </li>
      <li>
      Last but not least, unregister the FC from the registry.<br/>
      This is an important step since this FC has been created in memory, and will not be used persistently by another FC. So the best
      thing to do is to get rid of it, by unregistering it.
      </li>
      </ol>
    </p>
    <p>
      The whole code for the task class is the following one :
      <pre class="code">
/**
 * The dynamic HelloWorld task of the tutorial part 1 example.
 * @author t0076261
 */
public class DynamicHelloTask extends AbstractTask {
  /**
   * Referenced FC id.
   */
  private static final String REFERENCED_FC_ID = "factoryComponent.1204214642640.24"; //$NON-NLS-1$
  /**
   * Referenced contract element id (in referenced FC).
   */
  private static final String REFERENCED_FC_CONTRACT_ELEMENT_ID = "contractElement.1204217622578.29"; //$NON-NLS-1$
  /**
   * Current plug-in id.<br/>
   * If you're plug-in is declaring an activator, get it from the activator directly.
   */
  private static final String PLUGIN_ID = "org.eclipse.egf.examples.fc.helloworld.dynamic.test"; //$NON-NLS-1$

  /**
   * @see org.eclipse.egf.core.task.AbstractTask#doExecute(org.eclipse.core.runtime.IProgressMonitor)
   */
  @Override
  protected boolean doExecute(IProgressMonitor progressMonitor_p) {
    // Read the messages file.
    String helloMessages = FileHelper.readFile(PLUGIN_ID + "/resources/messages.txt"); //$NON-NLS-1$
    // Get messages.
    String[] messages = StringHelper.getTokens(helloMessages, ICommonConstants.EMPTY_STRING + ICommonConstants.COMMA_CHARACTER);
    // Create a FC dynamically.
    FactoryComponent factoryComponent = ModelFactory.eINSTANCE.createFactoryComponent();
    factoryComponent.setName("Dynamic HelloWorld Runner"); //$NON-NLS-1$
    // Set the factory.
    Factory factory = ModelFactory.eINSTANCE.createFactory();
    factoryComponent.setFactory(factory);
    // Add a production plan.
    ProductionPlan productionPlan = ModelFactory.eINSTANCE.createProductionPlan();
    factory.setProductionPlan(productionPlan);
    // Add call to HelloWorld for each message.
    for (String message : messages) {
      delegateToHelloWorld(productionPlan, message);
    }
    // Now the FC is ready for action.
    // Register it.
    FactoryComponentRegistry factoryComponentRegistry = CoreActivator.getDefault().getFactoryComponentRegistry();
    String factoryComponentId = factoryComponent.getId();
    factoryComponentRegistry.addFactoryComponent(factoryComponentId, factoryComponent);
    // Execute it.
    boolean result = CoreActivator.getDefault().generateFactoryComponent(factoryComponentId, progressMonitor_p, false);
    // The FC is no longer needed, unregister it.
    factoryComponentRegistry.removeFactoryComponent(factoryComponentId);
    return result;
  }

  /**
   * Add a new call to HelloWorld with given message.
   * @param productionPlan_p
   * @param helloMessage_p
   */
  protected void delegateToHelloWorld(ProductionPlan productionPlan_p, String helloMessage_p) {
    // Create a factory component invocation.
    FactoryComponentInvocation factoryComponentInvocation = ModelFactory.eINSTANCE.createFactoryComponentInvocation();
    // Add factory component invocation to production plan.
    productionPlan_p.getFactoryComponentInvocations().add(factoryComponentInvocation);
    factoryComponentInvocation.setFactoryComponentId(REFERENCED_FC_ID);
    // Add a default context.
    Context context = ModelFactory.eINSTANCE.createContext();
    factoryComponentInvocation.setContext(context);
    // Create empty context element and add it to context.
    ContextElement contextElement = ModelFactory.eINSTANCE.createContextElement();
    context.getContextElements().add(contextElement);
    // Create contract element reference and fill it.
    ContractElementReference contractElementRef = ModelFactory.eINSTANCE.createContractElementReference();
    contractElementRef.setReferencedFactoryComponentId(REFERENCED_FC_ID);
    contractElementRef.setReferencedContractElementId(REFERENCED_FC_CONTRACT_ELEMENT_ID);
    // Set context element reference.
    contextElement.setContractElementReference(contractElementRef);
    // Set context element value.
    contextElement.setReadableValue(helloMessage_p);
    // Set plug-in id.
    contextElement.setPluginId(PLUGIN_ID);
  }
}
      </pre>
      Let us comment a bit the <tt class="code">delegateToHelloWorld</tt> method.<br/>
      <p>
        For each hello message, a new FactoryComponentInvocation is created, just as it would be done in the Factory Component Explorer.
        Creating such an element requires to know exactly which FC is to be used (here HelloWorld).
        This is done by providing the id of the FC. Here it's located in the <tt class="code">REFERENCED_FC_ID</tt> constant.<br/>
        <img src="./images/tip.gif"/>Make sure you're replacing this value with the one of your HelloWorld FC. You can get this value by selecting the HelloWorld
        FC in the Factory Component Explorer and displaying its advanced properties. This is the one named <b>Id</b>.
      </p>
      <p>
        Just as we need to know the referenced FC id, we also need to know the referenced contract element id, so as to provide a
        context element that will give the contract a value.<br/>
        This is is located in the <tt class="code">REFERENCED_FC_CONTRACT_ELEMENT_ID</tt> constant.<br/>
        <img src="./images/tip.gif"/>Make sure you're replacing this one too. You can access its value by selecting the message contract
        of HelloWorld and displaying its advanced properties. This is again the one named <b>Id</b>.
      </p>
      <p>
        The easiest part is to provide the newly created context element with a value.<br/>
        Simply invoke <tt class="code">setReadableValue</tt> with the message to display.
      </p>
      <p>
        Providing the context element with the plug-in id can prove to be very useful.
        Although this is not required here, this is something you want to do each time.<br/>
        Indeed, for some <tt class="code">ITypeHolder</tt> implementations, this will cause errors not to provide it. Remember that
        the readable value is interpreted by the type holder in the end (at generation time).
      </p>
    </p>
    <p>
      One last thing to do, is to provide the HelloWorld Dynamic Test FC with data to read.<br/>
      Just create a text file named <b>messages.txt</b> in your <b>plug-in project root/resources</b> newly created (if not already
      existing) folder. The content of this file must be messages separated by commas, as displayed below :
      <pre>
      Melody,Mozart,Orchestra
      </pre>
      <img src="./images/tip.gif"/>You may also have to change the <tt class="code">PLUGIN_ID</tt> constant to fit your needs.
    </p>
  </p>

  <h3>Step 3. Execute HelloWorld Dynamic Test</h3>
  <p>
    This is just about either deploying the resulting plug-in and re-launching the workbench, or simply launching a new workbench from
    here. Then execute the HelloWorld Dynamic Test factory.<br/>
    The execution leads to having a dialog box per message in the provided messages.txt file.
  </p>
</p>
</body>
</html>